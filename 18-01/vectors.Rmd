---
title: "Основы программирования в R"
subtitle: "Лекция 1. Векторы в R"
author: "Алла Тамбовцева"
output: html_document
---

### Bекторы

Вектор -- список некоторых объектов. Создается он следующим образом:

```{r}
x <- c(1, 0, 0, 2) # вектор x
```

Можем на него посмотреть:

```{r}
x
```

Для тех, кто знаком с Python: вектор -- аналог списка (*list*) в Python, состоящего из элементов одного типа (элементы могут иметь разный тип, но тогда вектор будет уже немного не тот -- увидим позже).

Определить тип вектора:

```{r}
class(x)
```

И длину -- число элементов в векторе:

```{r}
length(x)
```

С числовыми векторами в R мы можем осуществлять те же операции, что и с векторами в математике. Но результаты не всегда совпадают. Например, обычное умножение векторов с помощью знака `*` не соответствует ни скалярному, ни векторному произведению векторов. Это происходит потому, что арифметические операции с векторами выполняются поэлементно.

```{r}
x <- c(1, 0, 0, 2) # вектор x
y <- c(0, 1, 1, 2) # вектор y

x + y # прибавляем к каждому элементу x элемент y
x * y 
3 * x - y
```

Также мы можем «склеивать» векторы, то есть приписывать в конец одного вектора элементы другого:

```{r}
result <- c(x, y) # склеиваем два вектора
result
```

Кроме того, можно суммировать и сами элементы вектора:

```{r}
x
sum(x) # сумма всех элементов вектора
```

Или находить их произведение:

```{r}
prod(x)
```

Или сортировать:

```{r}
sort(x)
sort(x, decreasing = TRUE) # по убыванию
```

Возможны векторы и из нечисловых значений:

```{r}
names <- c("Mary", "John", "Peter") 
```

**Внимание:** если в векторе встречаются как числовые значения, так и текстовые, то R будет воспринимать весь вектор как текстовый!

```{r}
mix <- c(1, "Mary", 0, "Peter")
class(mix)
```

При работе с данными нужно всегда внимательно относиться к типу объектов. Например, если у нас есть результаты опроса студентов, и мы видим, что пять респондентов не указали свой возраст, не стоит кодировать эти пропущенные значения словом «нет». Лучше оставить значения пропущенными или закодировать их заведомо невозможным значением (например, 1000), чтобы потом ответы этиих респондентов спокойно отфильтровать. Социологи так обычно и поступают: ответы на вопросы кодируются небольшими числами (например, от 1 до 6, от 1 до 10), а пропущенные значения кодируются числами 98 или 99.

### Преобразование типов

Как и у обычных переменных, у векторов можно изменять тип (тип всех элементов вектора). Например, можем преобразовать текстовый вектор в числовой с помощью функции `as.numeric()`:

```{r}
text <- c("2", "3", "5")
as.numeric(text)
```

При этом, если среди элементов есть дробное число, записанное, как текст, то все элементы вектора преобразуются в дробные числа:

```{r}
as.numeric(c("2.3", "6", "8"))
```

Грустная новость: если бы в "2.3" разделителем являлась запятая, ничего бы не получилось -- R в качестве разделителя разрядов признает только точку:

```{r}
old <- c("2,3", "6", "8")
as.numeric(old)
```

Что делать? В таком случае нужно сначала заменить запятую на точку с помощью `gsub()`, а уже потом преобразовывать: 

```{r}
new <- gsub(",", ".", old) # (что заменям, на что заменяем, где заменяем) 
as.numeric(new)
```


### Работа с элементами вектора

Для того, чтобы выбрать элементы вектора по их индексу (положению в векторе), нужно учитывать, что в R нумерация начинается с 1, а не с 0, как в Python и многих языках программирования.

```{r}
names <- c("Mary", "John", "Peter") 
names
names[1] # первый элемент вектора names
names[0] # не работает
names[1:2] # первые два элемента вектора names
```

Если нужно выбрать элементы, которые следуют в векторе не подряд, индексы интересующих нас элементов нужно оформить в виде вектора:

```{r}
names[c(1, 3)] # первый и третий
names[c(1:2, 2:3)] # срезы тоже можно перечислять в качестве элементов вектора
```

Обратите внимание: в отличие от Python, в R правый конец среза включается. Например, код `names[1:2]` вернёт первые два элемента, а не только элемент с индексом 1.

А теперь мы будем отбирать элементы вектора по их значению. Для этого необходимо указывать интересующие критерии выбора (условия) в квадратных скобках. Создадим вектор `v`:

```{r}
v <- c(1, 8, 9, 2, 3, 0, -1)
v
```

Выберем элементы вектора `v`, которые больше 3:

```{r}
v[v > 3] 
```

Усложним задачу. Будем выбирать только четные элементы вектора v. Для этого нам понадобится оператор для определения остатка от деления: `%%`. Четные элементы -- те, которые делятся на 2 без остатка. Значит, остаток от деления их на 2 должен быть равен нулю:

```{r}
v[v%%2 == 0] # только четные элементы
```

Условия можно сочетать:

```{r}
v[v > 3 & v%%2 == 0] # четные элементы больше 3 
```

Иногда нам нужно не найти элемент вектора по его номеру или по определенным критериям, а выполнить обратную задачу: вернуть индекс элемента (его порядковый номер в векторе). Это можно сделать так:

```{r}
names
which(names =='Jane') # двойной знак =
```

Можно также получать индексы элементов вектора, которые удовлетворяют определенным условиям:

```{r}
v
which(v > 3)
which(v%%2 == 0) # индексы четных чисел
```

А как быть, если мы хотим изменить вектор? Например, добавить значение? Все просто:

```{r}
p <- c(1, 2)
p[3] = 7 # добавим третий элемент
p
```

**Полезный факт:** Индекс последнего элемента вектора в R совпадает с длиной вектора.

Если нужно удалить элемент, это делается так:

```{r}
v[v != 8] # хотим убрать 8
```

Это работает и тогда, когда в векторе встречаются повторяющиеся значения -- убираются все совпадающие элементы:

```{r}
w <- c(6, 6, 6, 7)
w[w != 6]
```
