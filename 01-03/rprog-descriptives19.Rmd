---
title: "Основы программирования в R"
subtitle: "Описательные статистики"
author: "Алла Тамбовцева"
output: html_document
---
Сегодня обсудим интересную базу данных -- базу с экспериментальными данными по шоколадным тортикам (к политологии вернемся на семинаре). 

[Описание базы данных](https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/doc/lme4/cake.html). 

[Детали по эксперименту](http://r.789695.n4.nabble.com/New-details-about-Cochran-and-Cox-s-chocolate-cake-data-td4694001.html). 

Загрузим базу данных по ссылке:

```{r}
cakes <- read.csv("https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/lme4/cake.csv")
```

Посмотрим на неё:

```{r, eval=FALSE}
View(cakes)
```

Для вывода описательных статистик в R есть специальная функция `summary()`:

```{r}
summary(cakes)
```

Для количественных переменных эта функция выдает минимальное и максимальное значение, среднее арифметическое, медиану, нижний (`1st Qu.`) и верхний (`3rd Qu.`) квартиль. Нижний квартиль -- значение, которое 25% значений в выборке не превышают, а верхний квартиль -- значение, которое 75% значений в выборке не превышают. Для качественных переменных (текстовые, факторные), R будет выводить количество значений по каждой группе (уровню).

В данном случае по выдаче R мы можем определить следующее. Всего в базе данных у нас 270 наблюдений (переменная `X` здесь служит id наблюдений, а её максимальное значение 270), значит, в рамках исследования было приготовлено 270 шоколадных тортов. Минимальная температура, при которой выпекали торты, равна 175 градусам, максимальная — 225. Средняя температура, при которой выпекали торты, равна 200. Медианное значение температуры в данном случае совпадает со средним значением — в половине случаев температура при выпечке не превышала 200 градусов. Нижний квартиль равен 185 градусам — в 25% случаев торты выпекались при температуре не выше 185 градусов, верхний квартиль равен 215 — 75% случаев температура не превышала 215 градусов (или в 25% случаев превышала!). 

Необязательно выводить описательные статистики для всех переменных в базе данных, можно вывести описание одной переменной:

```{r}
summary(cakes$temperature)
```

Или проделать то же самое для нескольких переменных:

```{r}
summary(cakes[5:6])  # в скобках - индексы столбцов
```

Или так, по названиям столбцов: 

```{r}
summary(cakes[, c("angle", "temp")])
```

Точно так же необязательно выводить все статистики сразу. Можно запрашивать по отдельности:

```{r}
min(cakes$temp)  # минимум
max(cakes$temp)  # максимум
mean(cakes$temp)  # среднее
median(cakes$temp)  # медиана
```

Теперь посмотрим на квантили. Для примера запросим квантиль уровня 0.25 для переменной `temp`, то есть значение температуры, которое 25% значений в выборке не превышают.

```{r}
quantile(cakes$temp, 0.25)  # переменная, а затем уровень квантиля
```

Выдача для квантиля выглядит интересно: помимо самого значения выводится уровень 25%. Результат, который возвращает функция `quantile()`, является поименованным вектором, у каждого элемента вектора есть название. Здесь элемент один, и название одно, `25%`. 

Чтобы структура выдачи была понятна, давайте в качестве небольшого отступления создадим поименованный вектор `v`:

```{r}
v <- c(a = 2, b = 3, c = 4)
v
```

Для тех, кто знаком с Python: поименованный вектор похож на словарь, он тоже состоит из пар *ключ-значение*.

Если мы запросим сразу несколько квантилей, перечислим уровни в виде вектора, то всё тоже сработает:

```{r}
quantile(cakes$temp, c(0.25, 0.5, 0.75))
```

Можем задавать уровни в виде последовательности с заданным шагом. Вызовем децили — квантили с уровнями, кратными 10:

```{r}
quantile(cakes$temp, seq(from=0, to=1, by=0.1))
```

Ещё есть функция `fivenum()`, которая возвращает описательные статистики по Тьюки, те, которые используются для построения ящика с усами: минимум, нижняя граница типичных значений, медиана, верхняя граница типичных значений, максимум.

```{r}
fivenum(cakes$temp)
```

Это не единственные описательные статистики, которые можно вывести. Часто нас интересует не только среднее (или медианное) значение, а разброс значений относительно этого среднего. Для этого можем посчитать *выборочную дисперсию* или *стандартное отклонение*. 

```{r}
var(cakes$temp)  # дисперсия
sd(cakes$temp)  # стандартное отклонение
```

Но сами по себе эти значения не очень информативны -- по ним сложно понять, насколько однородны наши данные (сильно ли они разбросаны относительно среднего значения). Для того, чтобы оценить степень однородности наших данных, нашей выборки, можно воспользоваться таким показателем как *коэффициент вариации*. Коэффициент вариации считается несложно: стандартное отклонение нужно поделить на среднее значение. Обычно значение коэффициента вариации, взятое по модулю, лежит в пределах от 0 до 1, но иногда, если данные очень разнородны (стандартное отклонение большое), оно может быть больше 1. 

**Вопрос:** а когда коэффициент вариации нужно использовать с осторожностью? 

Часто коэффициент вариации выражают в процентах. Давайте напишем код, который будет считать коэффициент вариации в процентах для переменной `angle`. Ваш <s>ход</s> код, маэстро!

```{r}
sd(cakes$temp)/mean(cakes$temp) * 100
```

В данном случае все показатели считаются без проблем, потому что в базе данных все строки полностью заполнены. Если среди значений встречаются пропущенные (`NA`), то и результат тоже будет `NA`. Чтобы решить эту проблему, нужно прописать дополнительный аргумент `na.rm = TRUE`, который говорит R не учитывать пропущенные значения при расчете статистик (из самой базы значения при этом не выкидываются!). 

```{r}
ages <- c(23, 25, 27, NA)
mean(ages, na.rm = TRUE)
```

Готово!

Пока мы обсудили только описательные статистики для количественных переменных. А как быть с качественными? Какую информацию по ним можно получить? Число наблюдений, соответствующих каждому значению (классу):

```{r}
table(cakes$recipe)
```

В прошлый раз мы говорили о том, что для показателей, измеренных в качественной шкале, вычислять среднее или медиану бессмысленно, нужно смотреть на моду. Искать специальную функцию не нужно, достаточно помнить, что мода — это значение, которое встречается в выборке чаще всего (да, мода может быть не одна).

Кстати, для количественных переменных функция `table()` тоже хорошо работает:

```{r}
table(cakes$angle)
```

В заключение первой части знакомства с описательными статистиками в R давайте установим библиотеку `psych`, которая используется для психометрических исследований и посмотрим, какие у неё есть возможности, связанные с описанием данных. 

```{r, eval=FALSE}
install.packages("psych")
```

Обратимся к ней:

```{r, message=FALSE, warning=FALSE}
library(psych)
```

Теперь запросим описательные статистики с помощью функции `describe()`: 

```{r}
describe(cakes$temp)
```

Что есть что?

* `vars`: число описываемых переменных (не путать с `var` для дисперсии);
* `n`: число наблюдений; 
* `mean`: среднее арифметическое, выборочное среднее;
* `sd`: стандартное отклонение;
* `median`: медиана;
* `trimmed`: усечённое среднее, среднее по цензурированной выборке (см. ниже);
* `mad`: медианное значение абсолютного отклонения от медианы (нам не понадобится);
* `min`, `max`: минимальное и максимальное значение;
* `range`: размах;
* `skew`: коэффициент асимметрии или скошенности (см.нижк);
* `kurtosis`: коэффициент эксцесса (см. ниже);
* `se`: стандартная ошибка среднего (обсудим потом отдельно);

Подробнее про некоторые статистики.

*Усечённое среднее, среднее по цензурированной выборке*

* Считается так: выборка упорядочивается по возрастанию, из неё убирается 5% наблюдений слева и справа (наименьшие и наибольшие), потом по такой усечённой или цензурированной выборке считается обычное среднее арифметическое.

* Наравне с медианой считается более устойчивой оценкой среднего, так как после усечения выборки такой показатель уже несильно зависит от слишком больших или слишном маленьких (нетипичных) значений в выборке. То есть, при наличии нетипичных наблюдений в выборке (выбросов) такое среднее более адекватно отражает реальность, чем обычное среднее арифметическое.

*Коэффициент асимметрии*

* Показатель принимает значения примерно от -3 до 3. Значение 0 соответствует симметричному распределению (например, нормальному, вспомните график плотности, симметричный относительно математического ожидания). Значения меньше 0 соответствуют распределению, которое скошено влево (длинный хвост «слева»), значения больше 0 соответствуют распределению, которое скошено вправо (длинный «хвост» справа).

* В нашем случае распределение почти симметричное, коэффициент близок к нулю, но при это оно немного скошено вправо, поэтому значение больше 0.

*Коэффициент эксцесса*

* Показатель принимает значения примерно от -3 до 3 и отвечает за выраженность пика распределения. Чем больше значение коэффициента, тем более выраженный пик. Стандартное нормальное распределение имеет коэффициент эксцесса равный 0. Отрицательные значения коэффициента соответствуют более «плоским» и «гладким» распределениям, у которых пик не такой заметный. Посмотрите на картинку [здесь](https://en.wikipedia.org/wiki/Kurtosis#/media/File:Standard_symmetric_pdfs.png) и сравните.

* В нашем случае распределение несильно отличается от нормального, поэтому коэффициент близок к нулю. 

Библиотека `psych` удобна тем, что она содержит функцию `describeBy()`, которая позволяет выводить описательные статистики по группам. Нет необходимости отфильтровывать нужные строки и сохранять их в отдельные датасеты, можно просто указать группирующую переменную. Выведем описательные статистики для переменной `temp` отдельно для каждого рецепта (здесь у всех групп всё будет одинаково в силу специфики экспериментальных данных):

```{r}
describeBy(cakes$temp, cakes$recipe)
```

Очень удобно!