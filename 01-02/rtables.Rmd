---
title: "Основы программирования в R"
author: "Алла Тамбовцева"
subtitle: Лекция 3. Работа с файлами и таблицами в R.
output:
  pdf_document: default
  html_document: default
---

Изучив основные объекты в R, мы можем перейти к объектам, ради которых многие и начинают изучать R, а именно, к базам данных или датафреймам (точнее, к таблицам, просто в социально-экономических науках эти термины отождествляют, хотя, строго говоря, база данных - это набор связанных между собой таблиц). Но прежде необходимо научиться загружать файлы с данными, чтобы было с чем работать.

## Работа с файлами

### Загрузка данных в R

**Напоминание.** Если мы не хотим прописывать слишком длинный путь к файлу, файл с данными можно сохранить сразу в рабочую папку (папку, из которой запускается R). Тогда при попытке открыть файл с заданным названием R будет искать его в этой папке. Узнать, какая папка является рабочей, можно с помощью функции `getwd()`:

```{r}
getwd() # wd - от working directory
```

Рабочую папку можно изменить. Например, так:

```{r, eval=FALSE}
setwd("C:/AllaT/Рабочий стол/")
```

Для начала загрузим в R «простые» текстовые файлы. «Простые» в том смысле, что для их загрузки не требуется установки специальных библиотек.

**csv-файлы**

Формат csv (от *comma separated values*) - широко распространенный текстовый формат, который используется для представления табличных данных. В качестве разделителя, т.е. символа, который разделяет значения колонок, обычно используется запятая, как и следует из названия.

```{r, eval=FALSE}
df <- read.csv("example1.csv")
View(df) # посмотреть на базу данных, V - заглавная
```

Но иногда в качестве разделителя могут быть использованы другие символы (точка с запятой, пробел, табуляция). Если мы загрузим файл с другим разделителем и никак это не укажем, что загрузится совсем не то, что мы ожидали:

```{r, eval=FALSE}
df1 <- read.csv("example2.csv")
View(df1)
```

А если выставим нужный разделитель в качестве параметра, то все будет, как нужно:

```{r, eval=FALSE}
df1 <- read.csv("example2.csv", sep = ";") # sep - от separator
View(df1)
```

Если в файле есть текст на кириллице, могут возникнуть проблемы при чтении файла или при его отображении. Решения могут быть разными (зависит от системы, ее параметров и самого файла). Самое простое - специфицировать кодировку самого файла:

```{r, eval=FALSE}
df2 <- read.csv("example3.csv", encoding = "UTF-8")
df2 <- read.csv("example4.csv", encoding = "WINDOWS-1251")
```

Обычно текст в кодировке UTF-8 встречается в файлах, созданных в Mac OS или Linux, а WINDOWS-1251 (или CP-1251) - в Windows.

Будем считать, что с csv-файлами разобрались.

**txt-файлы**

При работе с txt-файлами необходимо указывать, каким образом столбцы отделены друг от друга (аргумент `sep`, разделитель, как и в случае в csv-файлами), а также учитывать, что представляет собой первая строка: наблюдение или шапку таблицы (аргумент `header`). Откроем файл, в котором столбы разделены табуляцией и сравним, как он будет выглядеть при выставлении разных значений параметра `header`:

```{r,eval=FALSE}
# header = T - первая строка читается как имя переменной
table1 <- read.table('example1.txt', sep='\t', header = TRUE)  
View(table1) 
```

```{r,eval=FALSE}
# header = F - первая строка читается как наблюдение
table2 <- read.table('example1.txt', sep='\t', header = FALSE)
View(table2) 
```

Теперь перейдем к другим форматам.

**файлы Excel**

Чтобы спокойно загружать xlsx-файлы в R можно установить специальные библиотеки: `xlsx` или `readxl`. С установкой первой библиотеки могут возникнуть проблемы: R будет писать что-то про rjava. Это обычно бывает, если на компьютере не установлена Java или установлена такая ее версия, которая конфликтует с R (например, недостаточно новая). Тогда Java можно поставить, скачав [отсюда](https://www.java.com/en/download/manual.jsp). После этого проблема должна исчезнуть, по крайней мере, на Windows.

```{r, eval=FALSE}
install.packages("xlsx")
```

Теперь обратимся к этой библиотеке - иначе открыть файл мы не сможем:

```{r, eval=FALSE}
library(xlsx)
```

Наконец, откроем сам файл. Не забудьте указать номер листа после запятой (даже если он всего один), иначе не сработает.

```{r, eval=FALSE}
ex_data <- read.xlsx("example1.xlsx", 1)
```

Иногда даже с переустановленной Java библиотека `xlsx` не хочет загружаться. Тогда можно пойти другим путем: в правом верхнем углу RStudio во вкладке *Environment* выбрать *Import Dataset-From Excel*, выбрать файл на компьютере через *Browse*, вписать название переменной, в которую сохраняем таблицу в R (например, `df`) в поле *Name* и нажать *Import*. Если в файле Excel более одного листа, тогда в поле *Sheet* нужно указать номер нужного листа.

Код, который исполняется, когда мы выполняем эти действия вручную, выглядит следующим образом:

```{r, eval=FALSE}
library(readxl)
df_ex <- read_excel("example1.xlsx")
```

То есть, можно установить библиотеку `readxl` (с ней не будет таких проблем с Java), обратиться к ней и спокойно использовать по аналогии с кодом выше.

**файлы STATA**

Для загрузки файлов STATA (файлы с расширением `.dta`) потребуется библиотека `foreign`.

```{r, eval=FALSE}
install.packages("foreign")
library(foreign)
```

Теперь загрузим dta-файл.

```{r, eval=FALSE}
stata_data <- read.dta("example1.dta")
```

**файлы SPSS**

Для загрузки файлов SPSS (файлы с расширением `.sav`) потребуется библиотека `Hmisc`.

```{r, eval=FALSE}
install.packages("Hmisc")
library(Hmisc)
```

Загрузим sav-файл.

```{r, eval=FALSE}
sav_data <- spss.get("example1.sav")
```

### Сохранение (экспорт) файлов

Выгружаются данные из R аналогичным образом, но только вместо `read` в названиях функций используется  `write`. Например, сохраним базу `df` в csv-формате:

```{r, eval=FALSE}
write.csv(df, "new_file.csv")
```

## Работа с таблицами

### Описание таблицы

Загрузим более содержательную таблицу. Таблицу, взятую с сайта IBM, содержащую данные об эффективности рекламных кампаний. Файл и codebook к ней можно найти [здесь](https://www.ibm.com/communities/analytics/watson-analytics-blog/marketing-campaign-eff-usec_-fastf/).

```{r}
dat <- read.csv("http://math-info.hse.ru/f/2018-19/comm-math/marketing.csv")
```

Какую информацию о таблице мы можем получить?

Можем определить число наблюдений и число переменных в датафрейме. Узнать это можно точно так же, как и размерность матрицы, ведь число строк - это число наблюдений, а число столбцов - это число переменных.

```{r}
dim(dat)
```

Или по отдельности:

```{r}
nrow(dat) # число строк
```

```{r}
ncol(dat) # число столбцов
```

Можем узнать гораздо больше - структуру датафрейма: число наблюдений и переменных, типы переменных и примеры значений, которые они принимают. Сделать это можно с помощью уже знакомой функции `str()`:

```{r}
str(dat)
```

Также легко посмотреть на первые несколько значений:

```{r}
head(dat)
```

Или последние:

```{r}
tail(dat)
```

Обсуждение вывода описательных статистик для переменных в базе данных оставим на потом, разберем этот вопрос более подробно, когда начнем разведывательный анализ данных. А пока поговорим о чуть более продвинутых вещах.

### Пропущенные значения

Результаты, которые выдают нам функции `str()` и `dim()`, содержат только общую информацию о количестве наблюдений в таблице и не дают никакой информации о пропущенных значениях. Как это исправить? Для начала можно выяснить, сколько в базе неполностью заполненных строк. Функция `complete.cases()` выдает логический вектор, где `TRUE` означает полностью заполненную строку, а `FALSE` - содержащую пропуски (NAs).

```{r}
head(complete.cases(dat)) # head - первые несколько значений
```

Посчитаем, сколько полностью заполненных наблюдений:

```{r}
sum(complete.cases(dat))
```

Соответственно, остальные (из 548) - недозаполненные (содержащие NAs).

Посмотрим на незаполненные строки:

```{r, eval=FALSE}
View(dat[!complete.cases(dat), ]) # ! отрицание
```

И посчитаем их количество:

```{r}
nrow(dat[!complete.cases(dat), ])
```

Для дальнейшей работы с пропущенными значениями нам понадобятся дополнительные библиотеки. Установим их. Можно устанавливать сразу несколько библиотек – оформить перечень необходимых библиотек в виде вектора, и тогда сразу после установки одной библиотеки начнется загрузка следующей.

```{r, eval=FALSE}
install.packages(c("mice", "VIM"))
```

Обратимся к ним:

```{r, warning=FALSE, message=FALSE}
library(mice)
library(VIM)
```

Выведем графики, которые покажут, в каких переменных пропущенных значений больше всего и как выглядит таблица с пропущенными значениями (паттерны пропущенных значений).

На графике слева показано, с какой частотой встречаются пропущенные значения в той или иной переменной. На графике справа показано, в каких комбинациях эти пропущенные значения встречаются. Например, в нашем случае отсутствие ответов в *AgeOfStore* часто совпадает с отсутствием ответов в *SalesInThousands* (пропущенные значения отмечены красным цветом).

```{r}
# aggr - из библиотеки mice
aggr(dat)
```

Следующий график отвечает за заполненность наблюдений (красным цветом отмечены пропущенные значения, остальное - заполненные значения, чем темнее цвет, тем больше значение). По вертикальной оси - номер строки в базе данных (id наблюдения).

```{r}
# matrixplot - из библиотеки VIM
matrixplot(dat) 
```

### Удаление пропущенных значений

При работе с базами данных необходимо удалить пропущенные значения (или правильно заполнить - кто умеет), потому что иначе мы не сможем полноценно работать с базой (многие функции не работают при наличии NAs, а у некоторых необходимо указывать дополнительный аргумент - учитывать NA или нет).

```{r}
# удаляем строки, содержащие NA
dat <- na.omit(dat)
```

### Выбор переменных

Если мы хотим обратиться к конкретной переменной и рассматривать ее как вектор элементов, нужно использовать символ `$`.

```{r}
dat$Promotion # номер рекламной кампании
```

**Attach и detach**

Мы можем «закрепить» базу данных с помощью команды `attach`, чтобы обращаться к переменным более простым способом:

```{r}
attach(dat) # заодно покажет, какие переменные есть
head(Promotion) # имя переменной как есть, без $
```

Однако это не всегда удобно, особенно если приходится работать с несколькими базами одновременно (наложение переменных с одинаковыми именами, проблемы с редактированием и прочее).

```{r}
detach(dat) # возвращаем обратно
```

Создание и добавление в базу новых переменных
Допустим, мы хотим добавить в базу переменную *Campaign*, которая будет содержать индекс рекламной кампании, но сохраненный как фактор (*factor*). Для этого нужно через `$` задать имя новой переменной и присвоить ей значение:

```{r}
dat$Campaign <- factor(dat$Promotion)
```

### Фильтрация наблюдений

Часто при работе с данными возникает необходимость выбрать несколько переменных или определенную группу наблюдений и анализировать их отдельно - чтобы не загружать каждый раз огромную базу с ненужными показателями.

Можем выбрать несколько переменных (столбцов) и сохранить их в другую базу:

```{r, eval=FALSE}
dat[2:4] # 2 и 4 - порядковые номера столбцов, от 2 до 4
```

Получится маленькая база из трех переменных. Сохраним её как новую базу `dat1`:

```{r, eval=FALSE}
dat1 <- dat[2:4] 
```

Если выбираем столбцы не подряд, обязательно их номера нужно оформить в виде вектора:

```{r, eval=FALSE}
dat[c(1, 3)] # не просто dat[1, 3]
```

В противном случае получится совсем не то:

```{r}
dat[1, 3] 
```

Это «совсем не то» связано с тем, что, когда мы указываем в квадратных скобках числа через запятую, R воспринимает первое число как номер строки, второе число - как номер столбца (как в матрицах - сначала строка, потом столбец). Можем посмотреть на исходную базу и убедиться в этом. Но зато таким образом мы можем выбирать строки (наблюдения):

```{r, eval=FALSE}
dat[, 1:3] # берем все строки, первые 3 столбца
```

Или столбцы:

```{r, eval=FALSE}
dat[1:4, ] # берем первые 4 строки, все столбцы
```

### Фильтрация по условиям

Если хотим отобрать из базы определенные наблюдения, это тоже можно сделать с помощью квадратных скобок. Например, мы хотим выбрать данные за первую неделю:

```{r}
week1 <- dat[dat$Week == 1, ]
```

Тут важно не забыть поставить запятую, чтобы R понимал, что 
мы накладываем условие на строки, а столбцы берём все, что есть. Можем сочетать условия. Например, выбрать данные за первую неделю по компаниям среднего уровня:

```{r, eval=FALSE}
View(dat[dat$Week == 1 & dat$MarketSize == "Medium", ])
```

Для тех же целей можно использовать встроенную функцию `subset()`:

```{r}
week1 <- subset(dat, Week == 1)
```

```{r}
week1_med <- subset(dat, Week == 1 & MarketSize == "Medium")
```

Конечно, можем отбирать наблюдения и переменные одновременно:

```{r}
dat_small <- subset(dat, Week == 1 & MarketSize == "Medium", select = c(MarketID, LocationID, AgeOfStore)) 
```

В коде выше мы выбрали столбцы *MarketID*, *LocationID*, *AgeOfStore*.

### Удаление переменных
Чтобы удалить переменные, можно действовать двумя способами:

* удалить их из базы
* оставить все остальные переменные в базе

По смыслу это одно и то же. И то, и другое чаще всего осуществляется с помощью функции `subset()`.

Допустим, мы хотим выбрать переменные *MarketID* и *SalesInThousands* и сохранить их в новую базу:

```{r}
# указываем имя базы, оставляем MarketID и SalesInThousands
dat1 <- subset(dat, select = c(MarketID, SalesInThousands)) 
```

А теперь хотим оставить все, кроме переменных *Week* и *AgeOfStore*:

```{r}
# перед вектором столбцов стоит минус
dat2 <- subset(dat, select = -c(Week, AgeOfStore)) 
```
