---
title: "Основы программирования в R"
subtitle: "Лекция 4. Работа с датафреймами средствами `dplyr`."
author: "Alla Tambovtseva"
output: html_document
---

### Работа с датафреймами с использованием `dplyr`

Библиотека `dplyr` – библиотека для удобной работы с датафреймами. С её помощью можно более быстро получать описание таблицы, сохранять полученные результаты и группировать данные по определенному признаку. Научиться работать с это библиотекой несложно, нужно только понять общую логику, познакомиться с особыми операторами и функциями, а также немного попрактиковаться.

Для начала установим библиотеку и обратимся к ней:

```{r, eval=FALSE}
install.packages("dplyr")
```

```{r, message=FALSE, warning=FALSE}
library(dplyr)
```

Теперь мы готовы к работе. Загрузим файл с результатами плебисцита 1988 года в Чили. Почитать про переменные в таблице можно [здесь](https://www.rdocumentation.org/packages/car/versions/2.1-5/topics/Chile).

```{r}
dat <- read.csv("http://math-info.hse.ru/f/2017-18/ps-ms/Chile.csv") 
```

### Основные функции `dplyr` и оператор `%>%`

Некоторые функции, встроенные в библиотеку, похожи на обычные функций, которые мы использовали на прошлом занятии. Например, функция `select()`, которая позволяет выбрать интересующие нас столбцы в датафрейме:

```{r, eval=FALSE}
small1 <- select(dat, sex, age, income, vote)
View(small1) 
```

Также с помощью `select()` можем исключить некоторые столбцы, которые нас не интересуют, поставив перед вектором столбцов минус (так же, как и раньше!):

```{r, eval=FALSE}
small2 <- select(dat, -c(X, region, population))
View(small2)
```

Столбцы можно выбирать по названиям, если столбцы идут подряд:

```{r}
head(select(dat, sex:vote)) # столбцы от sex до vote
```

Если хотим отобрать интересующие нас наблюдения, нам потребуется другая функция - `filter()`. Отберем, например, респондентов старше 45 лет:

```{r, eval=FALSE}
old <- filter(dat, age > 45)
View(old)
```

А теперь отберем респондентов мужского пола, старше 45 лет:

```{r, eval=FALSE}
old_m <- filter(dat, age > 45 & sex == "M")
View(old_m)
```

Казалось бы, зачем использовать библиотеку `dplyr`, если результаты пока несильно отличаются от того, что мы делали на прошлом занятии без всяких библиотек? На самом деле, смысл использовать её есть. И сейчас мы переходим к самому интересному.

В библиотеке `dplyr` есть особый оператор `%>%`, который позволяет выполнять операции пошагово. Смысл этого оператора такой: возьми, то, что слева от `%>%` и передай это на вход функции, стоящей справа от `%>%`. Посмотрим на простом примере:

```{r, eval=FALSE}
dat %>% View
```

Взять датафрейм `dat` и подать её на вход функции `View`. Как можно заметить, во `View` уже нет ни скобок, ни названия базы, потому что они и не нужны – R и так знает, с чем ему работать.

Рассмотрим другой пример. Возьмем таблицу `dat`, сначала выберем столбцы `sex`, `age`, `income` и `vote`, а потом запросим несколько первых строк датафрейма:

```{r}
dat %>% 
  select(sex, age, income, vote) %>% 
  head
```

В библиотеке `dplyr` есть несколько других интересных и полезных функций. Например, `arrange()` – функция, которая сортирует таблицу в соответствии со значениями переменной (или переменных), расположенных по возрастанию (если переменная текстовая, то по алфавиту). Отсортируем таблицу по показателю `statusquo` и посмотрим на первые несколько строк:

```{r}
dat %>% arrange(statusquo) %>% head
```

А теперь на последние:

```{r}
dat %>% arrange(statusquo) %>% tail
```

Другая полезная функция – `mutate()` – используется для создания и добавления в датафрейм новой переменной. Создадим переменную `log_income` – натуральный логарифм дохода респондентов.

```{r, eval=FALSE}
chile %>% 
  mutate(log_income = log(income))
```

Если теперь мы посмотрим на `dat` привычным образом, нас будет ждать сюрприз:

```{r, eval=FALSE}
View(dat)
```

Переменной `log_income` в датафрейме нет! Почему? Дело в том, что когда мы проделываем что-то с датафреймом с помощью `dplyr` и не сохраняем результат, изменения с самим датафреймом не происходят. Как сохранить изменения? Очень просто: как всегда, сохранить результат в переменную, в которой хранится датафрейм:

```{r}
dat <- dat %>% 
  mutate(log_income = log(income))
```

Добавлять можно и более одной переменной за раз:

```{r}
dat <- dat %>% 
  mutate(log_income = log(income), log_population = log(population))
str(dat)
```

Теперь у нас в базе данных есть две переменные, которые начинаются с `log`. В `dplyr` есть функция, которая позволяет выбрать столбцы, названия которых начинаются одинаково.

```{r}
dat %>% 
  select(starts_with("log_")) %>%
  head
```

Чтобы закрепить то, что мы уже успели разобрать, рассмотрим две задачи.

**Задача.** Выбрать строки в таблице, для которых значения `statusquo` не пустые (не `NA` в переменной `statusquo`), выбрать респондентов с доходом свыше 35000, отсортировать строки по возрасту респондентов и посмотреть на итоговую таблицу.

**Решение.**

```{r, eval=FALSE}
dat %>% 
  filter(!is.na(statusquo), income > 35000) %>% 
  arrange(age) %>% 
  View
```

Сначала мы выберем те строки в базе, для которых значения `statusquo` не пустые (`is.na()` и помним про отрицание - восклицательный знак), а заодно выберем респондентов с доходом более 35000. Затем с помощью `arrange()` отсортируем строки по значениям `age`. И, наконец, посмотрим на полученный датафрейм через `View`.
